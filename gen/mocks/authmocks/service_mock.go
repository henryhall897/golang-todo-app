// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package authmocks

import (
	"context"
	"github.com/henryhall897/golang-todo-app/internal/auth/domain"
	udomain "github.com/henryhall897/golang-todo-app/internal/users/domain"
	"sync"
)

// Ensure, that ServiceMock does implement domain.Service.
// If this is not the case, regenerate this file with moq.
var _ domain.Service = &ServiceMock{}

// ServiceMock is a mock implementation of domain.Service.
//
//	func TestSomethingThatUsesService(t *testing.T) {
//
//		// make and configure a mocked domain.Service
//		mockedService := &ServiceMock{
//			LoginOrRegisterFunc: func(ctx context.Context, input domain.AuthLoginParams) (string, udomain.User, error) {
//				panic("mock out the LoginOrRegister method")
//			},
//			LogoutFunc: func(ctx context.Context, token string) error {
//				panic("mock out the Logout method")
//			},
//		}
//
//		// use mockedService in code that requires domain.Service
//		// and then make assertions.
//
//	}
type ServiceMock struct {
	// LoginOrRegisterFunc mocks the LoginOrRegister method.
	LoginOrRegisterFunc func(ctx context.Context, input domain.AuthLoginParams) (string, udomain.User, error)

	// LogoutFunc mocks the Logout method.
	LogoutFunc func(ctx context.Context, token string) error

	// calls tracks calls to the methods.
	calls struct {
		// LoginOrRegister holds details about calls to the LoginOrRegister method.
		LoginOrRegister []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input domain.AuthLoginParams
		}
		// Logout holds details about calls to the Logout method.
		Logout []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token string
		}
	}
	lockLoginOrRegister sync.RWMutex
	lockLogout          sync.RWMutex
}

// LoginOrRegister calls LoginOrRegisterFunc.
func (mock *ServiceMock) LoginOrRegister(ctx context.Context, input domain.AuthLoginParams) (string, udomain.User, error) {
	if mock.LoginOrRegisterFunc == nil {
		panic("ServiceMock.LoginOrRegisterFunc: method is nil but Service.LoginOrRegister was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Input domain.AuthLoginParams
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockLoginOrRegister.Lock()
	mock.calls.LoginOrRegister = append(mock.calls.LoginOrRegister, callInfo)
	mock.lockLoginOrRegister.Unlock()
	return mock.LoginOrRegisterFunc(ctx, input)
}

// LoginOrRegisterCalls gets all the calls that were made to LoginOrRegister.
// Check the length with:
//
//	len(mockedService.LoginOrRegisterCalls())
func (mock *ServiceMock) LoginOrRegisterCalls() []struct {
	Ctx   context.Context
	Input domain.AuthLoginParams
} {
	var calls []struct {
		Ctx   context.Context
		Input domain.AuthLoginParams
	}
	mock.lockLoginOrRegister.RLock()
	calls = mock.calls.LoginOrRegister
	mock.lockLoginOrRegister.RUnlock()
	return calls
}

// Logout calls LogoutFunc.
func (mock *ServiceMock) Logout(ctx context.Context, token string) error {
	if mock.LogoutFunc == nil {
		panic("ServiceMock.LogoutFunc: method is nil but Service.Logout was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Token string
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockLogout.Lock()
	mock.calls.Logout = append(mock.calls.Logout, callInfo)
	mock.lockLogout.Unlock()
	return mock.LogoutFunc(ctx, token)
}

// LogoutCalls gets all the calls that were made to Logout.
// Check the length with:
//
//	len(mockedService.LogoutCalls())
func (mock *ServiceMock) LogoutCalls() []struct {
	Ctx   context.Context
	Token string
} {
	var calls []struct {
		Ctx   context.Context
		Token string
	}
	mock.lockLogout.RLock()
	calls = mock.calls.Logout
	mock.lockLogout.RUnlock()
	return calls
}
