// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package authmocks

import (
	"context"
	"github.com/henryhall897/golang-todo-app/internal/auth/domain"
	"sync"
	"time"
)

// Ensure, that CacheMock does implement domain.Cache.
// If this is not the case, regenerate this file with moq.
var _ domain.Cache = &CacheMock{}

// CacheMock is a mock implementation of domain.Cache.
//
//	func TestSomethingThatUsesCache(t *testing.T) {
//
//		// make and configure a mocked domain.Cache
//		mockedCache := &CacheMock{
//			BlacklistTokenFunc: func(ctx context.Context, jti string, ttl time.Duration) error {
//				panic("mock out the BlacklistToken method")
//			},
//			DeleteAuthIdentityFunc: func(ctx context.Context, authID string) error {
//				panic("mock out the DeleteAuthIdentity method")
//			},
//			GetAuthIdentityFunc: func(ctx context.Context, authID string) (domain.AuthIdentity, error) {
//				panic("mock out the GetAuthIdentity method")
//			},
//			IsTokenBlacklistedFunc: func(ctx context.Context, jti string) (bool, error) {
//				panic("mock out the IsTokenBlacklisted method")
//			},
//			SetAuthIdentityFunc: func(ctx context.Context, authIdentity domain.AuthIdentity) error {
//				panic("mock out the SetAuthIdentity method")
//			},
//		}
//
//		// use mockedCache in code that requires domain.Cache
//		// and then make assertions.
//
//	}
type CacheMock struct {
	// BlacklistTokenFunc mocks the BlacklistToken method.
	BlacklistTokenFunc func(ctx context.Context, jti string, ttl time.Duration) error

	// DeleteAuthIdentityFunc mocks the DeleteAuthIdentity method.
	DeleteAuthIdentityFunc func(ctx context.Context, authID string) error

	// GetAuthIdentityFunc mocks the GetAuthIdentity method.
	GetAuthIdentityFunc func(ctx context.Context, authID string) (domain.AuthIdentity, error)

	// IsTokenBlacklistedFunc mocks the IsTokenBlacklisted method.
	IsTokenBlacklistedFunc func(ctx context.Context, jti string) (bool, error)

	// SetAuthIdentityFunc mocks the SetAuthIdentity method.
	SetAuthIdentityFunc func(ctx context.Context, authIdentity domain.AuthIdentity) error

	// calls tracks calls to the methods.
	calls struct {
		// BlacklistToken holds details about calls to the BlacklistToken method.
		BlacklistToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Jti is the jti argument value.
			Jti string
			// TTL is the ttl argument value.
			TTL time.Duration
		}
		// DeleteAuthIdentity holds details about calls to the DeleteAuthIdentity method.
		DeleteAuthIdentity []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AuthID is the authID argument value.
			AuthID string
		}
		// GetAuthIdentity holds details about calls to the GetAuthIdentity method.
		GetAuthIdentity []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AuthID is the authID argument value.
			AuthID string
		}
		// IsTokenBlacklisted holds details about calls to the IsTokenBlacklisted method.
		IsTokenBlacklisted []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Jti is the jti argument value.
			Jti string
		}
		// SetAuthIdentity holds details about calls to the SetAuthIdentity method.
		SetAuthIdentity []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AuthIdentity is the authIdentity argument value.
			AuthIdentity domain.AuthIdentity
		}
	}
	lockBlacklistToken     sync.RWMutex
	lockDeleteAuthIdentity sync.RWMutex
	lockGetAuthIdentity    sync.RWMutex
	lockIsTokenBlacklisted sync.RWMutex
	lockSetAuthIdentity    sync.RWMutex
}

// BlacklistToken calls BlacklistTokenFunc.
func (mock *CacheMock) BlacklistToken(ctx context.Context, jti string, ttl time.Duration) error {
	if mock.BlacklistTokenFunc == nil {
		panic("CacheMock.BlacklistTokenFunc: method is nil but Cache.BlacklistToken was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Jti string
		TTL time.Duration
	}{
		Ctx: ctx,
		Jti: jti,
		TTL: ttl,
	}
	mock.lockBlacklistToken.Lock()
	mock.calls.BlacklistToken = append(mock.calls.BlacklistToken, callInfo)
	mock.lockBlacklistToken.Unlock()
	return mock.BlacklistTokenFunc(ctx, jti, ttl)
}

// BlacklistTokenCalls gets all the calls that were made to BlacklistToken.
// Check the length with:
//
//	len(mockedCache.BlacklistTokenCalls())
func (mock *CacheMock) BlacklistTokenCalls() []struct {
	Ctx context.Context
	Jti string
	TTL time.Duration
} {
	var calls []struct {
		Ctx context.Context
		Jti string
		TTL time.Duration
	}
	mock.lockBlacklistToken.RLock()
	calls = mock.calls.BlacklistToken
	mock.lockBlacklistToken.RUnlock()
	return calls
}

// DeleteAuthIdentity calls DeleteAuthIdentityFunc.
func (mock *CacheMock) DeleteAuthIdentity(ctx context.Context, authID string) error {
	if mock.DeleteAuthIdentityFunc == nil {
		panic("CacheMock.DeleteAuthIdentityFunc: method is nil but Cache.DeleteAuthIdentity was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		AuthID string
	}{
		Ctx:    ctx,
		AuthID: authID,
	}
	mock.lockDeleteAuthIdentity.Lock()
	mock.calls.DeleteAuthIdentity = append(mock.calls.DeleteAuthIdentity, callInfo)
	mock.lockDeleteAuthIdentity.Unlock()
	return mock.DeleteAuthIdentityFunc(ctx, authID)
}

// DeleteAuthIdentityCalls gets all the calls that were made to DeleteAuthIdentity.
// Check the length with:
//
//	len(mockedCache.DeleteAuthIdentityCalls())
func (mock *CacheMock) DeleteAuthIdentityCalls() []struct {
	Ctx    context.Context
	AuthID string
} {
	var calls []struct {
		Ctx    context.Context
		AuthID string
	}
	mock.lockDeleteAuthIdentity.RLock()
	calls = mock.calls.DeleteAuthIdentity
	mock.lockDeleteAuthIdentity.RUnlock()
	return calls
}

// GetAuthIdentity calls GetAuthIdentityFunc.
func (mock *CacheMock) GetAuthIdentity(ctx context.Context, authID string) (domain.AuthIdentity, error) {
	if mock.GetAuthIdentityFunc == nil {
		panic("CacheMock.GetAuthIdentityFunc: method is nil but Cache.GetAuthIdentity was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		AuthID string
	}{
		Ctx:    ctx,
		AuthID: authID,
	}
	mock.lockGetAuthIdentity.Lock()
	mock.calls.GetAuthIdentity = append(mock.calls.GetAuthIdentity, callInfo)
	mock.lockGetAuthIdentity.Unlock()
	return mock.GetAuthIdentityFunc(ctx, authID)
}

// GetAuthIdentityCalls gets all the calls that were made to GetAuthIdentity.
// Check the length with:
//
//	len(mockedCache.GetAuthIdentityCalls())
func (mock *CacheMock) GetAuthIdentityCalls() []struct {
	Ctx    context.Context
	AuthID string
} {
	var calls []struct {
		Ctx    context.Context
		AuthID string
	}
	mock.lockGetAuthIdentity.RLock()
	calls = mock.calls.GetAuthIdentity
	mock.lockGetAuthIdentity.RUnlock()
	return calls
}

// IsTokenBlacklisted calls IsTokenBlacklistedFunc.
func (mock *CacheMock) IsTokenBlacklisted(ctx context.Context, jti string) (bool, error) {
	if mock.IsTokenBlacklistedFunc == nil {
		panic("CacheMock.IsTokenBlacklistedFunc: method is nil but Cache.IsTokenBlacklisted was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Jti string
	}{
		Ctx: ctx,
		Jti: jti,
	}
	mock.lockIsTokenBlacklisted.Lock()
	mock.calls.IsTokenBlacklisted = append(mock.calls.IsTokenBlacklisted, callInfo)
	mock.lockIsTokenBlacklisted.Unlock()
	return mock.IsTokenBlacklistedFunc(ctx, jti)
}

// IsTokenBlacklistedCalls gets all the calls that were made to IsTokenBlacklisted.
// Check the length with:
//
//	len(mockedCache.IsTokenBlacklistedCalls())
func (mock *CacheMock) IsTokenBlacklistedCalls() []struct {
	Ctx context.Context
	Jti string
} {
	var calls []struct {
		Ctx context.Context
		Jti string
	}
	mock.lockIsTokenBlacklisted.RLock()
	calls = mock.calls.IsTokenBlacklisted
	mock.lockIsTokenBlacklisted.RUnlock()
	return calls
}

// SetAuthIdentity calls SetAuthIdentityFunc.
func (mock *CacheMock) SetAuthIdentity(ctx context.Context, authIdentity domain.AuthIdentity) error {
	if mock.SetAuthIdentityFunc == nil {
		panic("CacheMock.SetAuthIdentityFunc: method is nil but Cache.SetAuthIdentity was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		AuthIdentity domain.AuthIdentity
	}{
		Ctx:          ctx,
		AuthIdentity: authIdentity,
	}
	mock.lockSetAuthIdentity.Lock()
	mock.calls.SetAuthIdentity = append(mock.calls.SetAuthIdentity, callInfo)
	mock.lockSetAuthIdentity.Unlock()
	return mock.SetAuthIdentityFunc(ctx, authIdentity)
}

// SetAuthIdentityCalls gets all the calls that were made to SetAuthIdentity.
// Check the length with:
//
//	len(mockedCache.SetAuthIdentityCalls())
func (mock *CacheMock) SetAuthIdentityCalls() []struct {
	Ctx          context.Context
	AuthIdentity domain.AuthIdentity
} {
	var calls []struct {
		Ctx          context.Context
		AuthIdentity domain.AuthIdentity
	}
	mock.lockSetAuthIdentity.RLock()
	calls = mock.calls.SetAuthIdentity
	mock.lockSetAuthIdentity.RUnlock()
	return calls
}
