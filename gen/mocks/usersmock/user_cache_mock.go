// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package usersmock

import (
	"context"
	"github.com/google/uuid"
	"github.com/henryhall897/golang-todo-app/internal/users/domain"
	"sync"
)

// Ensure, that CacheMock does implement domain.Cache.
// If this is not the case, regenerate this file with moq.
var _ domain.Cache = &CacheMock{}

// CacheMock is a mock implementation of domain.Cache.
//
//	func TestSomethingThatUsesCache(t *testing.T) {
//
//		// make and configure a mocked domain.Cache
//		mockedCache := &CacheMock{
//			CacheUserByEmailFunc: func(ctx context.Context, user domain.User) error {
//				panic("mock out the CacheUserByEmail method")
//			},
//			CacheUserByIDFunc: func(ctx context.Context, user domain.User) error {
//				panic("mock out the CacheUserByID method")
//			},
//			CacheUserByPaginationFunc: func(ctx context.Context, users []domain.User, params domain.GetUsersParams) error {
//				panic("mock out the CacheUserByPagination method")
//			},
//			DeleteUserByEmailFunc: func(ctx context.Context, email string) error {
//				panic("mock out the DeleteUserByEmail method")
//			},
//			DeleteUserByIDFunc: func(ctx context.Context, id uuid.UUID) error {
//				panic("mock out the DeleteUserByID method")
//			},
//			GetUserByEmailFunc: func(ctx context.Context, email string) (domain.User, error) {
//				panic("mock out the GetUserByEmail method")
//			},
//			GetUserByIDFunc: func(ctx context.Context, id uuid.UUID) (domain.User, error) {
//				panic("mock out the GetUserByID method")
//			},
//			GetUserByPaginationFunc: func(ctx context.Context, params domain.GetUsersParams) ([]domain.User, error) {
//				panic("mock out the GetUserByPagination method")
//			},
//		}
//
//		// use mockedCache in code that requires domain.Cache
//		// and then make assertions.
//
//	}
type CacheMock struct {
	// CacheUserByEmailFunc mocks the CacheUserByEmail method.
	CacheUserByEmailFunc func(ctx context.Context, user domain.User) error

	// CacheUserByIDFunc mocks the CacheUserByID method.
	CacheUserByIDFunc func(ctx context.Context, user domain.User) error

	// CacheUserByPaginationFunc mocks the CacheUserByPagination method.
	CacheUserByPaginationFunc func(ctx context.Context, users []domain.User, params domain.GetUsersParams) error

	// DeleteUserByEmailFunc mocks the DeleteUserByEmail method.
	DeleteUserByEmailFunc func(ctx context.Context, email string) error

	// DeleteUserByIDFunc mocks the DeleteUserByID method.
	DeleteUserByIDFunc func(ctx context.Context, id uuid.UUID) error

	// GetUserByEmailFunc mocks the GetUserByEmail method.
	GetUserByEmailFunc func(ctx context.Context, email string) (domain.User, error)

	// GetUserByIDFunc mocks the GetUserByID method.
	GetUserByIDFunc func(ctx context.Context, id uuid.UUID) (domain.User, error)

	// GetUserByPaginationFunc mocks the GetUserByPagination method.
	GetUserByPaginationFunc func(ctx context.Context, params domain.GetUsersParams) ([]domain.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// CacheUserByEmail holds details about calls to the CacheUserByEmail method.
		CacheUserByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User domain.User
		}
		// CacheUserByID holds details about calls to the CacheUserByID method.
		CacheUserByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User domain.User
		}
		// CacheUserByPagination holds details about calls to the CacheUserByPagination method.
		CacheUserByPagination []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Users is the users argument value.
			Users []domain.User
			// Params is the params argument value.
			Params domain.GetUsersParams
		}
		// DeleteUserByEmail holds details about calls to the DeleteUserByEmail method.
		DeleteUserByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
		}
		// DeleteUserByID holds details about calls to the DeleteUserByID method.
		DeleteUserByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetUserByEmail holds details about calls to the GetUserByEmail method.
		GetUserByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
		}
		// GetUserByID holds details about calls to the GetUserByID method.
		GetUserByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetUserByPagination holds details about calls to the GetUserByPagination method.
		GetUserByPagination []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params domain.GetUsersParams
		}
	}
	lockCacheUserByEmail      sync.RWMutex
	lockCacheUserByID         sync.RWMutex
	lockCacheUserByPagination sync.RWMutex
	lockDeleteUserByEmail     sync.RWMutex
	lockDeleteUserByID        sync.RWMutex
	lockGetUserByEmail        sync.RWMutex
	lockGetUserByID           sync.RWMutex
	lockGetUserByPagination   sync.RWMutex
}

// CacheUserByEmail calls CacheUserByEmailFunc.
func (mock *CacheMock) CacheUserByEmail(ctx context.Context, user domain.User) error {
	if mock.CacheUserByEmailFunc == nil {
		panic("CacheMock.CacheUserByEmailFunc: method is nil but Cache.CacheUserByEmail was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		User domain.User
	}{
		Ctx:  ctx,
		User: user,
	}
	mock.lockCacheUserByEmail.Lock()
	mock.calls.CacheUserByEmail = append(mock.calls.CacheUserByEmail, callInfo)
	mock.lockCacheUserByEmail.Unlock()
	return mock.CacheUserByEmailFunc(ctx, user)
}

// CacheUserByEmailCalls gets all the calls that were made to CacheUserByEmail.
// Check the length with:
//
//	len(mockedCache.CacheUserByEmailCalls())
func (mock *CacheMock) CacheUserByEmailCalls() []struct {
	Ctx  context.Context
	User domain.User
} {
	var calls []struct {
		Ctx  context.Context
		User domain.User
	}
	mock.lockCacheUserByEmail.RLock()
	calls = mock.calls.CacheUserByEmail
	mock.lockCacheUserByEmail.RUnlock()
	return calls
}

// CacheUserByID calls CacheUserByIDFunc.
func (mock *CacheMock) CacheUserByID(ctx context.Context, user domain.User) error {
	if mock.CacheUserByIDFunc == nil {
		panic("CacheMock.CacheUserByIDFunc: method is nil but Cache.CacheUserByID was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		User domain.User
	}{
		Ctx:  ctx,
		User: user,
	}
	mock.lockCacheUserByID.Lock()
	mock.calls.CacheUserByID = append(mock.calls.CacheUserByID, callInfo)
	mock.lockCacheUserByID.Unlock()
	return mock.CacheUserByIDFunc(ctx, user)
}

// CacheUserByIDCalls gets all the calls that were made to CacheUserByID.
// Check the length with:
//
//	len(mockedCache.CacheUserByIDCalls())
func (mock *CacheMock) CacheUserByIDCalls() []struct {
	Ctx  context.Context
	User domain.User
} {
	var calls []struct {
		Ctx  context.Context
		User domain.User
	}
	mock.lockCacheUserByID.RLock()
	calls = mock.calls.CacheUserByID
	mock.lockCacheUserByID.RUnlock()
	return calls
}

// CacheUserByPagination calls CacheUserByPaginationFunc.
func (mock *CacheMock) CacheUserByPagination(ctx context.Context, users []domain.User, params domain.GetUsersParams) error {
	if mock.CacheUserByPaginationFunc == nil {
		panic("CacheMock.CacheUserByPaginationFunc: method is nil but Cache.CacheUserByPagination was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Users  []domain.User
		Params domain.GetUsersParams
	}{
		Ctx:    ctx,
		Users:  users,
		Params: params,
	}
	mock.lockCacheUserByPagination.Lock()
	mock.calls.CacheUserByPagination = append(mock.calls.CacheUserByPagination, callInfo)
	mock.lockCacheUserByPagination.Unlock()
	return mock.CacheUserByPaginationFunc(ctx, users, params)
}

// CacheUserByPaginationCalls gets all the calls that were made to CacheUserByPagination.
// Check the length with:
//
//	len(mockedCache.CacheUserByPaginationCalls())
func (mock *CacheMock) CacheUserByPaginationCalls() []struct {
	Ctx    context.Context
	Users  []domain.User
	Params domain.GetUsersParams
} {
	var calls []struct {
		Ctx    context.Context
		Users  []domain.User
		Params domain.GetUsersParams
	}
	mock.lockCacheUserByPagination.RLock()
	calls = mock.calls.CacheUserByPagination
	mock.lockCacheUserByPagination.RUnlock()
	return calls
}

// DeleteUserByEmail calls DeleteUserByEmailFunc.
func (mock *CacheMock) DeleteUserByEmail(ctx context.Context, email string) error {
	if mock.DeleteUserByEmailFunc == nil {
		panic("CacheMock.DeleteUserByEmailFunc: method is nil but Cache.DeleteUserByEmail was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Email string
	}{
		Ctx:   ctx,
		Email: email,
	}
	mock.lockDeleteUserByEmail.Lock()
	mock.calls.DeleteUserByEmail = append(mock.calls.DeleteUserByEmail, callInfo)
	mock.lockDeleteUserByEmail.Unlock()
	return mock.DeleteUserByEmailFunc(ctx, email)
}

// DeleteUserByEmailCalls gets all the calls that were made to DeleteUserByEmail.
// Check the length with:
//
//	len(mockedCache.DeleteUserByEmailCalls())
func (mock *CacheMock) DeleteUserByEmailCalls() []struct {
	Ctx   context.Context
	Email string
} {
	var calls []struct {
		Ctx   context.Context
		Email string
	}
	mock.lockDeleteUserByEmail.RLock()
	calls = mock.calls.DeleteUserByEmail
	mock.lockDeleteUserByEmail.RUnlock()
	return calls
}

// DeleteUserByID calls DeleteUserByIDFunc.
func (mock *CacheMock) DeleteUserByID(ctx context.Context, id uuid.UUID) error {
	if mock.DeleteUserByIDFunc == nil {
		panic("CacheMock.DeleteUserByIDFunc: method is nil but Cache.DeleteUserByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteUserByID.Lock()
	mock.calls.DeleteUserByID = append(mock.calls.DeleteUserByID, callInfo)
	mock.lockDeleteUserByID.Unlock()
	return mock.DeleteUserByIDFunc(ctx, id)
}

// DeleteUserByIDCalls gets all the calls that were made to DeleteUserByID.
// Check the length with:
//
//	len(mockedCache.DeleteUserByIDCalls())
func (mock *CacheMock) DeleteUserByIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockDeleteUserByID.RLock()
	calls = mock.calls.DeleteUserByID
	mock.lockDeleteUserByID.RUnlock()
	return calls
}

// GetUserByEmail calls GetUserByEmailFunc.
func (mock *CacheMock) GetUserByEmail(ctx context.Context, email string) (domain.User, error) {
	if mock.GetUserByEmailFunc == nil {
		panic("CacheMock.GetUserByEmailFunc: method is nil but Cache.GetUserByEmail was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Email string
	}{
		Ctx:   ctx,
		Email: email,
	}
	mock.lockGetUserByEmail.Lock()
	mock.calls.GetUserByEmail = append(mock.calls.GetUserByEmail, callInfo)
	mock.lockGetUserByEmail.Unlock()
	return mock.GetUserByEmailFunc(ctx, email)
}

// GetUserByEmailCalls gets all the calls that were made to GetUserByEmail.
// Check the length with:
//
//	len(mockedCache.GetUserByEmailCalls())
func (mock *CacheMock) GetUserByEmailCalls() []struct {
	Ctx   context.Context
	Email string
} {
	var calls []struct {
		Ctx   context.Context
		Email string
	}
	mock.lockGetUserByEmail.RLock()
	calls = mock.calls.GetUserByEmail
	mock.lockGetUserByEmail.RUnlock()
	return calls
}

// GetUserByID calls GetUserByIDFunc.
func (mock *CacheMock) GetUserByID(ctx context.Context, id uuid.UUID) (domain.User, error) {
	if mock.GetUserByIDFunc == nil {
		panic("CacheMock.GetUserByIDFunc: method is nil but Cache.GetUserByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetUserByID.Lock()
	mock.calls.GetUserByID = append(mock.calls.GetUserByID, callInfo)
	mock.lockGetUserByID.Unlock()
	return mock.GetUserByIDFunc(ctx, id)
}

// GetUserByIDCalls gets all the calls that were made to GetUserByID.
// Check the length with:
//
//	len(mockedCache.GetUserByIDCalls())
func (mock *CacheMock) GetUserByIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockGetUserByID.RLock()
	calls = mock.calls.GetUserByID
	mock.lockGetUserByID.RUnlock()
	return calls
}

// GetUserByPagination calls GetUserByPaginationFunc.
func (mock *CacheMock) GetUserByPagination(ctx context.Context, params domain.GetUsersParams) ([]domain.User, error) {
	if mock.GetUserByPaginationFunc == nil {
		panic("CacheMock.GetUserByPaginationFunc: method is nil but Cache.GetUserByPagination was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params domain.GetUsersParams
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockGetUserByPagination.Lock()
	mock.calls.GetUserByPagination = append(mock.calls.GetUserByPagination, callInfo)
	mock.lockGetUserByPagination.Unlock()
	return mock.GetUserByPaginationFunc(ctx, params)
}

// GetUserByPaginationCalls gets all the calls that were made to GetUserByPagination.
// Check the length with:
//
//	len(mockedCache.GetUserByPaginationCalls())
func (mock *CacheMock) GetUserByPaginationCalls() []struct {
	Ctx    context.Context
	Params domain.GetUsersParams
} {
	var calls []struct {
		Ctx    context.Context
		Params domain.GetUsersParams
	}
	mock.lockGetUserByPagination.RLock()
	calls = mock.calls.GetUserByPagination
	mock.lockGetUserByPagination.RUnlock()
	return calls
}
