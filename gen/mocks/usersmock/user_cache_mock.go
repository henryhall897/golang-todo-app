// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package usersmock

import (
	"context"
	"github.com/google/uuid"
	"github.com/henryhall897/golang-todo-app/internal/users/domain"
	"sync"
)

// Ensure, that CacheMock does implement domain.Cache.
// If this is not the case, regenerate this file with moq.
var _ domain.Cache = &CacheMock{}

// CacheMock is a mock implementation of domain.Cache.
//
//	func TestSomethingThatUsesCache(t *testing.T) {
//
//		// make and configure a mocked domain.Cache
//		mockedCache := &CacheMock{
//			CacheUserFunc: func(ctx context.Context, user domain.User) error {
//				panic("mock out the CacheUser method")
//			},
//			CacheUserByPaginationFunc: func(ctx context.Context, users []domain.User, params domain.GetUsersParams) error {
//				panic("mock out the CacheUserByPagination method")
//			},
//			DeleteUserByEmailFunc: func(ctx context.Context, email string) error {
//				panic("mock out the DeleteUserByEmail method")
//			},
//			DeleteUserByIDFunc: func(ctx context.Context, id uuid.UUID) error {
//				panic("mock out the DeleteUserByID method")
//			},
//			GetUserByAuthIDFunc: func(ctx context.Context, authID string) (domain.User, error) {
//				panic("mock out the GetUserByAuthID method")
//			},
//			GetUserByEmailFunc: func(ctx context.Context, email string) (domain.User, error) {
//				panic("mock out the GetUserByEmail method")
//			},
//			GetUserByIDFunc: func(ctx context.Context, id uuid.UUID) (domain.User, error) {
//				panic("mock out the GetUserByID method")
//			},
//			GetUserByPaginationFunc: func(ctx context.Context, params domain.GetUsersParams) ([]domain.User, error) {
//				panic("mock out the GetUserByPagination method")
//			},
//		}
//
//		// use mockedCache in code that requires domain.Cache
//		// and then make assertions.
//
//	}
type CacheMock struct {
	// CacheUserFunc mocks the CacheUser method.
	CacheUserFunc func(ctx context.Context, user domain.User) error

	// CacheUserByPaginationFunc mocks the CacheUserByPagination method.
	CacheUserByPaginationFunc func(ctx context.Context, users []domain.User, params domain.GetUsersParams) error

	// DeleteUserByEmailFunc mocks the DeleteUserByEmail method.
	DeleteUserByEmailFunc func(ctx context.Context, email string) error

	// DeleteUserByIDFunc mocks the DeleteUserByID method.
	DeleteUserByIDFunc func(ctx context.Context, id uuid.UUID) error

	// GetUserByAuthIDFunc mocks the GetUserByAuthID method.
	GetUserByAuthIDFunc func(ctx context.Context, authID string) (domain.User, error)

	// GetUserByEmailFunc mocks the GetUserByEmail method.
	GetUserByEmailFunc func(ctx context.Context, email string) (domain.User, error)

	// GetUserByIDFunc mocks the GetUserByID method.
	GetUserByIDFunc func(ctx context.Context, id uuid.UUID) (domain.User, error)

	// GetUserByPaginationFunc mocks the GetUserByPagination method.
	GetUserByPaginationFunc func(ctx context.Context, params domain.GetUsersParams) ([]domain.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// CacheUser holds details about calls to the CacheUser method.
		CacheUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User domain.User
		}
		// CacheUserByPagination holds details about calls to the CacheUserByPagination method.
		CacheUserByPagination []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Users is the users argument value.
			Users []domain.User
			// Params is the params argument value.
			Params domain.GetUsersParams
		}
		// DeleteUserByEmail holds details about calls to the DeleteUserByEmail method.
		DeleteUserByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
		}
		// DeleteUserByID holds details about calls to the DeleteUserByID method.
		DeleteUserByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetUserByAuthID holds details about calls to the GetUserByAuthID method.
		GetUserByAuthID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AuthID is the authID argument value.
			AuthID string
		}
		// GetUserByEmail holds details about calls to the GetUserByEmail method.
		GetUserByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
		}
		// GetUserByID holds details about calls to the GetUserByID method.
		GetUserByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetUserByPagination holds details about calls to the GetUserByPagination method.
		GetUserByPagination []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params domain.GetUsersParams
		}
	}
	lockCacheUser             sync.RWMutex
	lockCacheUserByPagination sync.RWMutex
	lockDeleteUserByEmail     sync.RWMutex
	lockDeleteUserByID        sync.RWMutex
	lockGetUserByAuthID       sync.RWMutex
	lockGetUserByEmail        sync.RWMutex
	lockGetUserByID           sync.RWMutex
	lockGetUserByPagination   sync.RWMutex
}

// CacheUser calls CacheUserFunc.
func (mock *CacheMock) CacheUser(ctx context.Context, user domain.User) error {
	if mock.CacheUserFunc == nil {
		panic("CacheMock.CacheUserFunc: method is nil but Cache.CacheUser was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		User domain.User
	}{
		Ctx:  ctx,
		User: user,
	}
	mock.lockCacheUser.Lock()
	mock.calls.CacheUser = append(mock.calls.CacheUser, callInfo)
	mock.lockCacheUser.Unlock()
	return mock.CacheUserFunc(ctx, user)
}

// CacheUserCalls gets all the calls that were made to CacheUser.
// Check the length with:
//
//	len(mockedCache.CacheUserCalls())
func (mock *CacheMock) CacheUserCalls() []struct {
	Ctx  context.Context
	User domain.User
} {
	var calls []struct {
		Ctx  context.Context
		User domain.User
	}
	mock.lockCacheUser.RLock()
	calls = mock.calls.CacheUser
	mock.lockCacheUser.RUnlock()
	return calls
}

// CacheUserByPagination calls CacheUserByPaginationFunc.
func (mock *CacheMock) CacheUserByPagination(ctx context.Context, users []domain.User, params domain.GetUsersParams) error {
	if mock.CacheUserByPaginationFunc == nil {
		panic("CacheMock.CacheUserByPaginationFunc: method is nil but Cache.CacheUserByPagination was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Users  []domain.User
		Params domain.GetUsersParams
	}{
		Ctx:    ctx,
		Users:  users,
		Params: params,
	}
	mock.lockCacheUserByPagination.Lock()
	mock.calls.CacheUserByPagination = append(mock.calls.CacheUserByPagination, callInfo)
	mock.lockCacheUserByPagination.Unlock()
	return mock.CacheUserByPaginationFunc(ctx, users, params)
}

// CacheUserByPaginationCalls gets all the calls that were made to CacheUserByPagination.
// Check the length with:
//
//	len(mockedCache.CacheUserByPaginationCalls())
func (mock *CacheMock) CacheUserByPaginationCalls() []struct {
	Ctx    context.Context
	Users  []domain.User
	Params domain.GetUsersParams
} {
	var calls []struct {
		Ctx    context.Context
		Users  []domain.User
		Params domain.GetUsersParams
	}
	mock.lockCacheUserByPagination.RLock()
	calls = mock.calls.CacheUserByPagination
	mock.lockCacheUserByPagination.RUnlock()
	return calls
}

// DeleteUserByEmail calls DeleteUserByEmailFunc.
func (mock *CacheMock) DeleteUserByEmail(ctx context.Context, email string) error {
	if mock.DeleteUserByEmailFunc == nil {
		panic("CacheMock.DeleteUserByEmailFunc: method is nil but Cache.DeleteUserByEmail was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Email string
	}{
		Ctx:   ctx,
		Email: email,
	}
	mock.lockDeleteUserByEmail.Lock()
	mock.calls.DeleteUserByEmail = append(mock.calls.DeleteUserByEmail, callInfo)
	mock.lockDeleteUserByEmail.Unlock()
	return mock.DeleteUserByEmailFunc(ctx, email)
}

// DeleteUserByEmailCalls gets all the calls that were made to DeleteUserByEmail.
// Check the length with:
//
//	len(mockedCache.DeleteUserByEmailCalls())
func (mock *CacheMock) DeleteUserByEmailCalls() []struct {
	Ctx   context.Context
	Email string
} {
	var calls []struct {
		Ctx   context.Context
		Email string
	}
	mock.lockDeleteUserByEmail.RLock()
	calls = mock.calls.DeleteUserByEmail
	mock.lockDeleteUserByEmail.RUnlock()
	return calls
}

// DeleteUserByID calls DeleteUserByIDFunc.
func (mock *CacheMock) DeleteUserByID(ctx context.Context, id uuid.UUID) error {
	if mock.DeleteUserByIDFunc == nil {
		panic("CacheMock.DeleteUserByIDFunc: method is nil but Cache.DeleteUserByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteUserByID.Lock()
	mock.calls.DeleteUserByID = append(mock.calls.DeleteUserByID, callInfo)
	mock.lockDeleteUserByID.Unlock()
	return mock.DeleteUserByIDFunc(ctx, id)
}

// DeleteUserByIDCalls gets all the calls that were made to DeleteUserByID.
// Check the length with:
//
//	len(mockedCache.DeleteUserByIDCalls())
func (mock *CacheMock) DeleteUserByIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockDeleteUserByID.RLock()
	calls = mock.calls.DeleteUserByID
	mock.lockDeleteUserByID.RUnlock()
	return calls
}

// GetUserByAuthID calls GetUserByAuthIDFunc.
func (mock *CacheMock) GetUserByAuthID(ctx context.Context, authID string) (domain.User, error) {
	if mock.GetUserByAuthIDFunc == nil {
		panic("CacheMock.GetUserByAuthIDFunc: method is nil but Cache.GetUserByAuthID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		AuthID string
	}{
		Ctx:    ctx,
		AuthID: authID,
	}
	mock.lockGetUserByAuthID.Lock()
	mock.calls.GetUserByAuthID = append(mock.calls.GetUserByAuthID, callInfo)
	mock.lockGetUserByAuthID.Unlock()
	return mock.GetUserByAuthIDFunc(ctx, authID)
}

// GetUserByAuthIDCalls gets all the calls that were made to GetUserByAuthID.
// Check the length with:
//
//	len(mockedCache.GetUserByAuthIDCalls())
func (mock *CacheMock) GetUserByAuthIDCalls() []struct {
	Ctx    context.Context
	AuthID string
} {
	var calls []struct {
		Ctx    context.Context
		AuthID string
	}
	mock.lockGetUserByAuthID.RLock()
	calls = mock.calls.GetUserByAuthID
	mock.lockGetUserByAuthID.RUnlock()
	return calls
}

// GetUserByEmail calls GetUserByEmailFunc.
func (mock *CacheMock) GetUserByEmail(ctx context.Context, email string) (domain.User, error) {
	if mock.GetUserByEmailFunc == nil {
		panic("CacheMock.GetUserByEmailFunc: method is nil but Cache.GetUserByEmail was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Email string
	}{
		Ctx:   ctx,
		Email: email,
	}
	mock.lockGetUserByEmail.Lock()
	mock.calls.GetUserByEmail = append(mock.calls.GetUserByEmail, callInfo)
	mock.lockGetUserByEmail.Unlock()
	return mock.GetUserByEmailFunc(ctx, email)
}

// GetUserByEmailCalls gets all the calls that were made to GetUserByEmail.
// Check the length with:
//
//	len(mockedCache.GetUserByEmailCalls())
func (mock *CacheMock) GetUserByEmailCalls() []struct {
	Ctx   context.Context
	Email string
} {
	var calls []struct {
		Ctx   context.Context
		Email string
	}
	mock.lockGetUserByEmail.RLock()
	calls = mock.calls.GetUserByEmail
	mock.lockGetUserByEmail.RUnlock()
	return calls
}

// GetUserByID calls GetUserByIDFunc.
func (mock *CacheMock) GetUserByID(ctx context.Context, id uuid.UUID) (domain.User, error) {
	if mock.GetUserByIDFunc == nil {
		panic("CacheMock.GetUserByIDFunc: method is nil but Cache.GetUserByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetUserByID.Lock()
	mock.calls.GetUserByID = append(mock.calls.GetUserByID, callInfo)
	mock.lockGetUserByID.Unlock()
	return mock.GetUserByIDFunc(ctx, id)
}

// GetUserByIDCalls gets all the calls that were made to GetUserByID.
// Check the length with:
//
//	len(mockedCache.GetUserByIDCalls())
func (mock *CacheMock) GetUserByIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockGetUserByID.RLock()
	calls = mock.calls.GetUserByID
	mock.lockGetUserByID.RUnlock()
	return calls
}

// GetUserByPagination calls GetUserByPaginationFunc.
func (mock *CacheMock) GetUserByPagination(ctx context.Context, params domain.GetUsersParams) ([]domain.User, error) {
	if mock.GetUserByPaginationFunc == nil {
		panic("CacheMock.GetUserByPaginationFunc: method is nil but Cache.GetUserByPagination was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params domain.GetUsersParams
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockGetUserByPagination.Lock()
	mock.calls.GetUserByPagination = append(mock.calls.GetUserByPagination, callInfo)
	mock.lockGetUserByPagination.Unlock()
	return mock.GetUserByPaginationFunc(ctx, params)
}

// GetUserByPaginationCalls gets all the calls that were made to GetUserByPagination.
// Check the length with:
//
//	len(mockedCache.GetUserByPaginationCalls())
func (mock *CacheMock) GetUserByPaginationCalls() []struct {
	Ctx    context.Context
	Params domain.GetUsersParams
} {
	var calls []struct {
		Ctx    context.Context
		Params domain.GetUsersParams
	}
	mock.lockGetUserByPagination.RLock()
	calls = mock.calls.GetUserByPagination
	mock.lockGetUserByPagination.RUnlock()
	return calls
}
