// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package jwtmock

import (
	"context"
	udomain "github.com/henryhall897/golang-todo-app/internal/users/domain"
	"github.com/henryhall897/golang-todo-app/pkg/jwt/domain"
	"sync"
)

// Ensure, that TokenGeneratorMock does implement domain.TokenGenerator.
// If this is not the case, regenerate this file with moq.
var _ domain.TokenGenerator = &TokenGeneratorMock{}

// TokenGeneratorMock is a mock implementation of domain.TokenGenerator.
//
//	func TestSomethingThatUsesTokenGenerator(t *testing.T) {
//
//		// make and configure a mocked domain.TokenGenerator
//		mockedTokenGenerator := &TokenGeneratorMock{
//			GenerateTokenFunc: func(ctx context.Context, user udomain.User) (string, error) {
//				panic("mock out the GenerateToken method")
//			},
//			ParseTokenFunc: func(ctx context.Context, tokenString string) (domain.TokenClaims, error) {
//				panic("mock out the ParseToken method")
//			},
//		}
//
//		// use mockedTokenGenerator in code that requires domain.TokenGenerator
//		// and then make assertions.
//
//	}
type TokenGeneratorMock struct {
	// GenerateTokenFunc mocks the GenerateToken method.
	GenerateTokenFunc func(ctx context.Context, user udomain.User) (string, error)

	// ParseTokenFunc mocks the ParseToken method.
	ParseTokenFunc func(ctx context.Context, tokenString string) (domain.TokenClaims, error)

	// calls tracks calls to the methods.
	calls struct {
		// GenerateToken holds details about calls to the GenerateToken method.
		GenerateToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User udomain.User
		}
		// ParseToken holds details about calls to the ParseToken method.
		ParseToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TokenString is the tokenString argument value.
			TokenString string
		}
	}
	lockGenerateToken sync.RWMutex
	lockParseToken    sync.RWMutex
}

// GenerateToken calls GenerateTokenFunc.
func (mock *TokenGeneratorMock) GenerateToken(ctx context.Context, user udomain.User) (string, error) {
	if mock.GenerateTokenFunc == nil {
		panic("TokenGeneratorMock.GenerateTokenFunc: method is nil but TokenGenerator.GenerateToken was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		User udomain.User
	}{
		Ctx:  ctx,
		User: user,
	}
	mock.lockGenerateToken.Lock()
	mock.calls.GenerateToken = append(mock.calls.GenerateToken, callInfo)
	mock.lockGenerateToken.Unlock()
	return mock.GenerateTokenFunc(ctx, user)
}

// GenerateTokenCalls gets all the calls that were made to GenerateToken.
// Check the length with:
//
//	len(mockedTokenGenerator.GenerateTokenCalls())
func (mock *TokenGeneratorMock) GenerateTokenCalls() []struct {
	Ctx  context.Context
	User udomain.User
} {
	var calls []struct {
		Ctx  context.Context
		User udomain.User
	}
	mock.lockGenerateToken.RLock()
	calls = mock.calls.GenerateToken
	mock.lockGenerateToken.RUnlock()
	return calls
}

// ParseToken calls ParseTokenFunc.
func (mock *TokenGeneratorMock) ParseToken(ctx context.Context, tokenString string) (domain.TokenClaims, error) {
	if mock.ParseTokenFunc == nil {
		panic("TokenGeneratorMock.ParseTokenFunc: method is nil but TokenGenerator.ParseToken was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		TokenString string
	}{
		Ctx:         ctx,
		TokenString: tokenString,
	}
	mock.lockParseToken.Lock()
	mock.calls.ParseToken = append(mock.calls.ParseToken, callInfo)
	mock.lockParseToken.Unlock()
	return mock.ParseTokenFunc(ctx, tokenString)
}

// ParseTokenCalls gets all the calls that were made to ParseToken.
// Check the length with:
//
//	len(mockedTokenGenerator.ParseTokenCalls())
func (mock *TokenGeneratorMock) ParseTokenCalls() []struct {
	Ctx         context.Context
	TokenString string
} {
	var calls []struct {
		Ctx         context.Context
		TokenString string
	}
	mock.lockParseToken.RLock()
	calls = mock.calls.ParseToken
	mock.lockParseToken.RUnlock()
	return calls
}
