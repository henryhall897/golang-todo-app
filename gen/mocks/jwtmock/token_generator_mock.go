// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package jwtmock

import (
	"context"
	"github.com/henryhall897/golang-todo-app/pkg/jwt/domain"
	"sync"
)

// Ensure, that TokenGeneratorMock does implement domain.TokenGenerator.
// If this is not the case, regenerate this file with moq.
var _ domain.TokenGenerator = &TokenGeneratorMock{}

// TokenGeneratorMock is a mock implementation of domain.TokenGenerator.
//
//	func TestSomethingThatUsesTokenGenerator(t *testing.T) {
//
//		// make and configure a mocked domain.TokenGenerator
//		mockedTokenGenerator := &TokenGeneratorMock{
//			GenFunc: func(ctx context.Context, user domain.Payload) (string, error) {
//				panic("mock out the Gen method")
//			},
//			ParseFunc: func(ctx context.Context, tokenString string) (domain.Claims, error) {
//				panic("mock out the Parse method")
//			},
//		}
//
//		// use mockedTokenGenerator in code that requires domain.TokenGenerator
//		// and then make assertions.
//
//	}
type TokenGeneratorMock struct {
	// GenFunc mocks the Gen method.
	GenFunc func(ctx context.Context, user domain.Payload) (string, error)

	// ParseFunc mocks the Parse method.
	ParseFunc func(ctx context.Context, tokenString string) (domain.Claims, error)

	// calls tracks calls to the methods.
	calls struct {
		// Gen holds details about calls to the Gen method.
		Gen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User domain.Payload
		}
		// Parse holds details about calls to the Parse method.
		Parse []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TokenString is the tokenString argument value.
			TokenString string
		}
	}
	lockGen   sync.RWMutex
	lockParse sync.RWMutex
}

// Gen calls GenFunc.
func (mock *TokenGeneratorMock) Gen(ctx context.Context, user domain.Payload) (string, error) {
	if mock.GenFunc == nil {
		panic("TokenGeneratorMock.GenFunc: method is nil but TokenGenerator.Gen was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		User domain.Payload
	}{
		Ctx:  ctx,
		User: user,
	}
	mock.lockGen.Lock()
	mock.calls.Gen = append(mock.calls.Gen, callInfo)
	mock.lockGen.Unlock()
	return mock.GenFunc(ctx, user)
}

// GenCalls gets all the calls that were made to Gen.
// Check the length with:
//
//	len(mockedTokenGenerator.GenCalls())
func (mock *TokenGeneratorMock) GenCalls() []struct {
	Ctx  context.Context
	User domain.Payload
} {
	var calls []struct {
		Ctx  context.Context
		User domain.Payload
	}
	mock.lockGen.RLock()
	calls = mock.calls.Gen
	mock.lockGen.RUnlock()
	return calls
}

// Parse calls ParseFunc.
func (mock *TokenGeneratorMock) Parse(ctx context.Context, tokenString string) (domain.Claims, error) {
	if mock.ParseFunc == nil {
		panic("TokenGeneratorMock.ParseFunc: method is nil but TokenGenerator.Parse was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		TokenString string
	}{
		Ctx:         ctx,
		TokenString: tokenString,
	}
	mock.lockParse.Lock()
	mock.calls.Parse = append(mock.calls.Parse, callInfo)
	mock.lockParse.Unlock()
	return mock.ParseFunc(ctx, tokenString)
}

// ParseCalls gets all the calls that were made to Parse.
// Check the length with:
//
//	len(mockedTokenGenerator.ParseCalls())
func (mock *TokenGeneratorMock) ParseCalls() []struct {
	Ctx         context.Context
	TokenString string
} {
	var calls []struct {
		Ctx         context.Context
		TokenString string
	}
	mock.lockParse.RLock()
	calls = mock.calls.Parse
	mock.lockParse.RUnlock()
	return calls
}
